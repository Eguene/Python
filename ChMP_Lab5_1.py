##лучше прочитай все комментарии и не забудь их удалить, если будешь использовать этот код.
import numpy as np
matr = np.matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])##если будет матрица на 4 строки, вставишь сразу после [7, 8, 9] ", [a, b, c]", на 5 - вставь снова и т.д. И не забудь поменять числа в скобках, а так же a, b и с на свои числа, в следующей строке тоже.
vect = np.matrix([[10], [11], [12]])
def GauMet(matr, vect):##GauMet - название функции. Меняй, на какое хочешь, но в последней строке тогда тоже не забудь поменять
    n = len(vect)##измеряем длинну вектора, n равен ей.
    k = 1
    while k <= n-1:
        i = k+1
        while i<n: 
            if matr[i, k] != 0.0:##проверка на то, что первый член матрицы, который мы используем в рассчетах не равен нулю. Там в теории к лабе пишется, зачем.
                l = matr[i, k]/matr[k, k]
                matr[i, k+1:n] = matr[i, k+1:n] - matr[k, k+1:n]*l ## K+1:n написано вместо j. Почему - черт его знает, но это влияет на ответ.
                vect[i] = vect[i] - vect[k]*l
                print('check')##проверка на то, срабатывает ли условие, на всякий случай.
            i += 1
        k += 1
    k = n-1
    ##print('Check with .solve', np.linalg.solve(matr, vect)) ##можно раскоментить, и тогда оно выведет на экран решение этой ультимативной функцией solve, которая все решает правильно. Но лучше не надо, ответы могут не сойтись и будет плохо. Пишу это по коду ее студента, который она приводила в пример и говорила, что он правильный, но у него такая же проблема. Лучше просто удали эту строку, если собираешься использовать у себя именно этот код, от греха подальше.
    return vect
GauMet(matr, vect)