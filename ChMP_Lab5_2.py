##лучше прочитай все комментарии и не забудь их удалить, если будешь использовать этот код.
import numpy as np
matr = np.matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])##если будет матрица на 4 строки, вставишь сразу после [7, 8, 9] ", [a, b, c]", на 5 - вставь снова и т.д. И не забудь поменять числа в скобках, а так же a, b и с на свои числа, в следующей строке тоже.
vect = np.matrix([[10], [11], [12]])
x = np.matrix([[0], [0], [0]])
def GauMet(matr, vect):##GauMet - название функции. Меняй, на какое хочешь, но в последней строке тогда тоже не забудь поменять
    n = len(vect)##измеряем длинну вектора, n равен ей.
    k = 1
    while k <= n-1:
        i = k+1
        while i<n: 
            if matr[i, k] != 0.0:##проверка на то, что первый член матрицы, который мы используем в рассчетах не равен нулю. Там в теории к лабе пишется, зачем.
                l = matr[i, k]/matr[k, k]
                matr[i, k+1:n] = matr[i, k+1:n] - matr[k, k+1:n]*l ## K+1:n написано вместо j. Почему - черт его знает, но это влияет на ответ.
                vect[i] = vect[i] - vect[k]*l
                print('check')##проверка на то, срабатывает ли условие, на всякий случай.
            i += 1
        k += 1
    k = n-1
    print('Vector: ', vect)
    ##print('Check with .solve', np.linalg.solve(matr, vect)) ##можно раскоментить, и тогда оно выведет на экран решение этой ультимативной функцией solve, которая все решает правильно. Но лучше не надо, ответы могут не сойтись и будет плохо. Пишу это по коду ее студента, который она приводила в пример и говорила, что он правильный, но у него такая же проблема. Лучше просто удали эту строку, если собираешься использовать у себя именно этот код, от греха подальше.
    n = len(vect) - 1 ##тут начинается настоящее волшебство из костылей, потому что мне кажется, что ее схема просто неправильная. Я на паре тоже это не смог сделать, сколько не пытался. В общем, если оставить это, как было, то весь следующий код умирает, а вот если отнять 1, то работает. По причине жопа, наверное.
    x[n-1] = vect[n-1]/matr[n-1, n-1]##тут не лучше. если не писать -1, как в схеме сделано, то оно выходит за границы массива и все, смэрть. Опять таки, похоже, что схема с ошибками. Я не знаю.
    i = n-1
    while i >= 0:
        j = i
        ssum = 0
        while j <= n-1:
            ssum = ssum + matr[i, j]*x[j]
            j += 1
        x[i] = (vect[i] - ssum)/matr[i, j]
        print('X= ', x[i]) ##ах да, не надейся, что оно выведет на экран вссе три элемента x. Только два, потому что если сделать так, что бы три, весь код полетит. Чувствую себя сеньором питоновским, честное слово.
        i -= 1
GauMet(matr, vect)

    